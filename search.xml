<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 事件监听</title>
      <link href="posts/61223.html"/>
      <url>posts/61223.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-事件监听"><a href="#Vue-事件监听" class="headerlink" title="Vue 事件监听"></a>Vue 事件监听</h2><p>在前端开发中，我们需要经常和用户进行交互，这个时候我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等，在Vue中使用 v-on 指令。</p><p>v-on 介绍：</p><ul><li>作用：绑定事件监听器</li><li>缩写：@</li><li>预期：Function | Inline Statement | Object</li><li>参数：event</li></ul><h3 id="v-on-基本使用"><a href="#v-on-基本使用" class="headerlink" title="v-on 基本使用"></a>v-on 基本使用</h3><p>v-on 的基本使用如下：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;h2&gt;点击次数：{{counter}}&lt;/h2&gt;    &lt;button v-on:click="counter++"&gt;点击按钮&lt;/button&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        counter: 0,      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>在上边的代码中，我们使用了 v-on:click=”counter++”，还可以将事件指向一个在 methods 中定义的函数：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;h2&gt;点击次数：{{counter}}&lt;/h2&gt;    &lt;button v-on:click="btnClick"&gt;点击按钮&lt;/button&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        counter: 0,       },      methods: {        btnClick() {          this.counter++;        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>同时，v-on 也提供了对应的语法糖：</p><p>v-on:click 可以写成 @click。</p><pre><code>&lt;button @click="counter++"&gt;点击按钮&lt;/button&gt;&lt;button @click="btnClick"&gt;点击按钮&lt;/button&gt;</code></pre><h3 id="v-on-参数传递"><a href="#v-on-参数传递" class="headerlink" title="v-on 参数传递"></a>v-on 参数传递</h3><p>当通过 methods 中定义的方法，以供 @click 调用时，需要注意参数问题：</p><ul><li>如果该方法不需要额外参数，那么方法后的括号可以不添加。</li></ul><p>HTML 代码：</p><pre><code>&lt;button @click="btnClick"&gt;点击按钮&lt;/button&gt;</code></pre><p>Vue 代码：</p><pre><code> methods: {        btnClick() {          this.counter++;        },      },</code></pre><ul><li>如果方法本身中有一个参数，而在使用是未传参数，则会默认将原生事件 event 参数传递进去。</li></ul><p>HTML 代码：</p><pre><code>&lt;button @click="btnClick"&gt;点击按钮&lt;/button&gt;</code></pre><p>Vue 代码：</p><pre><code> methods: {        btnClick(abc) {          console.log(abc);        },      },</code></pre><p>执行结果：</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/24/ScQGEAZ91Oj6Pof.png" alt="未传参数调用.png"></p><ul><li>如果需要传入某个参数，同时需要 event 时，可以通过 $event 传入事件。</li></ul><p>HTML 代码：</p><pre><code>&lt;button @click="btnClick('123', $event)"&gt;点击按钮&lt;/button&gt;</code></pre><p>Vue 代码：</p><pre><code> methods: {        btnClick(abc, event) {          console.log(abc, event);        },      },</code></pre><blockquote><p>注意：调用时传入的参数需要使用引号引起来，否则解析时将会去找名叫 123 的变量。</p></blockquote><h3 id="v-on-修饰符"><a href="#v-on-修饰符" class="headerlink" title="v-on 修饰符"></a>v-on 修饰符</h3><p>在某些情况下，我们拿到 event 的目的可能是进行一些事件处理。</p><p>Vue 提供了修饰符来帮助我们方便的处理一些事件：</p><ul><li>.stop：调用 event.stopPropagation()，停止冒泡。</li><li>.prevent：调用 event.preventDefault()，阻止默认行为。</li><li>.{keyCode | keyAlias}：只当事件从特定键触发时才触发回调，使用键别名或键编码</li><li>.native：监听组件根元素的原生事件。</li><li>.once：指触发一次回调。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 事件监听 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6的let和const使用</title>
      <link href="posts/48682.html"/>
      <url>posts/48682.html</url>
      
        <content type="html"><![CDATA[<h2 id="let-、-var-和-const"><a href="#let-、-var-和-const" class="headerlink" title="let 、 var 和 const"></a>let 、 var 和 const</h2><p>var 的设计可以看做 JavaScript 语言设计上的错误，但是这种错误多半不能修复和移除，因为需要向后兼容。</p><p>大概十多年前，Brandan Eich 就决定修复这个问题，于是他添加了一个新的关键字：let。</p><p>我们可以将 let 看成更加完美的 var 。</p><h3 id="ES5-的作用域"><a href="#ES5-的作用域" class="headerlink" title="ES5 的作用域"></a>ES5 的作用域</h3><p> JavaScript 中使用 var 来声明一个变量时，变量的作用域主要是和函数的定义有关。在 ES5 中只有函数有作用域的。</p><p>变量作用域是指变量在什么范围内是可用的。而对于 var 来说，针对块定义来说是没有作用域的。比如：</p><pre><code>{  var name = 'apple';  console.log(name);}console.log(name);</code></pre><p>上述代码中均能打印出 name 的值，var的定义不受大括号（{}）的限制、另外在使用 if、for 时，往往会引入一些问题。</p><p>比如：</p><pre><code>&lt;body&gt;  &lt;button&gt;按钮1&lt;/button&gt;  &lt;button&gt;按钮2&lt;/button&gt;  &lt;button&gt;按钮3&lt;/button&gt;  &lt;button&gt;按钮4&lt;/button&gt;  &lt;button&gt;按钮5&lt;/button&gt;  &lt;script&gt;    var btns = document.getElementsByTagName("button");    for (var i = 0; i &lt; btns.length; i++) {      btns[i].onclick = function () {        alert("点击了按钮" + i);      };    }  &lt;/script&gt;&lt;/body&gt;</code></pre><p>在上述代码中，我们期望在点击按钮时，弹出的提示是对应点击的按钮名，但是实际执行的结果却一直是<code>按钮5</code> 。</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/24/aje264wGM5IOJCc.png" alt="var 作用域问题.png"></p><p>通常我们遇到这种问题，是使用闭包解决的，如：</p><pre><code>&lt;script&gt;  var btns = document.getElementsByTagName("button");  for (var i = 0; i &lt; btns.length; i++) {    (function (num) {      btns[i].onclick = function () {        alert("点击了按钮" + (num + 1));      };    })(i);  }&lt;/script&gt;</code></pre><p>执行结果如下：</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/24/KHXkEVntNAWpT2g.png" alt="闭包解决 for 作用域问题.png"></p><p>那么，为什么闭包可以解决 for 的作用域问题呢？</p><p>答案是因为：闭包是一个函数，函数是有作用域的，函数里的 i 不会被 for 循环修改。</p><h3 id="ES6-的作用域"><a href="#ES6-的作用域" class="headerlink" title="ES6 的作用域"></a>ES6 的作用域</h3><p>由于 ES5 之前 if 和 for 都没有块级作用域的概念，所以在很多时候，我们都必须借助于 function 的作用域来解决引用外面变量的问题。</p><p>所以在 SE6 中加入了 let ，而let是有 if 和 for 的块级 作用域的。</p><p>上边的代码可以改写为：</p><pre><code>for (let i = 0; i &lt; btns.length; i++) {      btns[i].onclick = function () {        alert("点击了按钮" + (i + 1));      };    }</code></pre><h3 id="ES6-的-const"><a href="#ES6-的-const" class="headerlink" title="ES6 的 const"></a>ES6 的 const</h3><p>const关键字：</p><p>在很多语言中已经存在，比如 C/C++ 中，主要的作用是将某个变量修饰为常量。</p><p>在 JavaScript 中也是如此，使用 const 修饰的变量为常量，不可以再次赋值。</p><p>当我们修饰的变量不会被再次赋值时，就可以使用 const 来保证数据的安全性。</p><p>const的注意点：</p><ul><li>必须进行初始化。</li><li>不能被修改。</li><li>常量的含义是指向的对象不能修改，但可以改变对象内部的属性。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
            <tag> let </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 属性操作 --- computed 计算属性</title>
      <link href="posts/25941.html"/>
      <url>posts/25941.html</url>
      
        <content type="html"><![CDATA[<h2 id="计算属性介绍"><a href="#计算属性介绍" class="headerlink" title="计算属性介绍"></a>计算属性介绍</h2><p>在模板中可以直接通过插值语法显示一些 data 中的数据，但是在某些情况下，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示。所以需要用到计算属性。</p><h3 id="计算属性基本用法"><a href="#计算属性基本用法" class="headerlink" title="计算属性基本用法"></a>计算属性基本用法</h3><p>比如我们有 firstName 和 lastName 两个变量，我们需要显示完整的名称，但是如果多个地方都需要显示完整的名称，我们就需要写多个  。</p><p>我们可以将上面的代码换算成计算属性：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;{{fullName}}&lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        firstName: "zhang",        lastName: "san",      },      computed: {        fullName: function () {          return this.firstName + " " + this.lastName;        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>在实际应用中，我们从服务器请求的数据往往更为复杂，通过计算属性的参与，将会更加方便。例如：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;图书的总价格为{{tatalPrice}}元&lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        books: [          { id: 100, name: "西游记", price: 180 },          { id: 101, name: "红楼梦", price: 165 },          { id: 102, name: "三国演义", price: 200 },          { id: 103, name: "水浒传", price: 190 },        ],      },      computed: {        tatalPrice: function () {          let result = 0;          for (let book of this.books) {            result += book.price;          }          return result;        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="计算属性的-setter-和-getter"><a href="#计算属性的-setter-和-getter" class="headerlink" title="计算属性的 setter 和 getter"></a>计算属性的 setter 和 getter</h3><p>每个计算属性都包含一个 getter 和一个 setter。</p><p>之前的计算属性写法为简写写法，完整的写法如下：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;{{fullName}}&lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        firstName: "zhang",        lastName: "san",      },      computed: {        fullName: {          set: function () {},          get: function () {            return this.firstName + " " + this.lastName;          },        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>计算属性一般没有 setter 方法，是只读属性，简写为：</p><pre><code>computed: {        fullName: {          get: function () {            return this.firstName + " " + this.lastName;          },        },</code></pre><p>再进一步简写为：</p><pre><code>computed: {        fullName: function () {            return this.firstName + " " + this.lastName;          },        },</code></pre><p>因此，计算属性在使用时，不需要加括号，他不是一个方法，是一个属性，是属性中只有一个 getter 方法，getter 方法的名称被隐藏了。</p><p>在上面的例子中，只是使用了 getter 来读取，在某些情况下，也可以提供一个 setter 方法（不常用），样例如下：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;{{fullName}}&lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        firstName: "zhang",        lastName: "san",      },      computed: {        fullName: {          set: function (newVule) {            const names = newVule.split(" ");            this.firstName = names[0];            this.lastName = names[1];          },          get: function () {            return this.firstName + " " + this.lastName;          },        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>在开发者模式中给fullName赋值为新的值，则会根据新值渲染界面。</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/22/7ujB81SKabvCp2O.png" alt="计算属性的setter"></p><h3 id="计算属性和-methods-的对比"><a href="#计算属性和-methods-的对比" class="headerlink" title="计算属性和 methods 的对比"></a>计算属性和 methods 的对比</h3><p>计算属性中的代码放到 methods 里面，也能实现效果，那么这两个有什么区别呢？</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;{{getFullName}}&lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        firstName: "zhang",        lastName: "san",      },      methods: {        getFullName: function () {          return this.firstName + " " + this.lastName;        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>在多次执行计算属性和methods方法时，可以做以下对比：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;div&gt;{{fullName}}&lt;/div&gt;    &lt;div&gt;{{fullName}}&lt;/div&gt;    &lt;div&gt;{{fullName}}&lt;/div&gt;    &lt;div&gt;{{fullName}}&lt;/div&gt;    &lt;div&gt;{{getFullName()}}&lt;/div&gt;    &lt;div&gt;{{getFullName()}}&lt;/div&gt;    &lt;div&gt;{{getFullName()}}&lt;/div&gt;    &lt;div&gt;{{getFullName()}}&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        firstName: "zhang",        lastName: "san",      },      computed: {        fullName: function () {          console.log("执行了computed");          return this.firstName + " " + this.lastName;        },      },      methods: {        getFullName: function () {          console.log("执行了methods");          return this.firstName + " " + this.lastName;        },      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>执行结果比较：</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/22/6bh2pyMPTjHFnID.png" alt="computed和methods的比较"></p><p>通过上述代码的比较，可以发现，计算属性的效率比 methods 的效率更高，在频繁使用时只执行一次。</p><p>当计算属性中的参数不变时，计算属性的结果会被Vue内部缓存，在每次使用时就不再调用计算，直接返回结果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 计算属性 </tag>
            
            <tag> computed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 属性操作 --- v-bind 指令</title>
      <link href="posts/3718.html"/>
      <url>posts/3718.html</url>
      
        <content type="html"><![CDATA[<h2 id="v-bind-介绍"><a href="#v-bind-介绍" class="headerlink" title="v-bind 介绍"></a>v-bind 介绍</h2><p>除了内容需要动态来决定外，某些属性也希望动态来绑定，如动态绑定<code>&lt;a&gt;</code>标签的<code>href</code>属性、动态绑定<code>&lt;img&gt;</code>的<code>src</code>属性，这个时候，我们就可以使用<code>v-bind</code>指令。</p><ul><li>作用：动态绑定属性。</li><li>缩写：“:”。</li><li>预期：any（with argument）|Object（without argument）</li><li>参数：attrOrProp（optional）</li></ul><h3 id="v-bind-基本使用"><a href="#v-bind-基本使用" class="headerlink" title="v-bind 基本使用"></a>v-bind 基本使用</h3><p>v-bind 用于绑定一个或多个属性值，或者向另一个组件传递 props 值，在开发中，存在很多属性需要动态绑定，例如图片的链接 src 、网站的链接 href 、动态绑定一些类、样式等。</p><p>在使用时，将属性值在 Vue 实例对象中进行定义，在 HTML 标签中使用<code>v-bind</code>进行绑定属性，在属性值中引用 Vue 实例对象中定义的值。</p><p>代码样例：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;img v-bind:src="imgUrL" /&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        imgUrL:    "https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1410814376,3908565210&amp;fm=26&amp;gp=0.jpg",      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>v-bind 有一个对应的语法糖，也就是简写方式。在开发中，通常使用语法糖的形式，因为这样更加简洁。</p><p>简写方式如下：</p><pre><code>&lt;div id="app"&gt;  &lt;img :src="imgUrL" /&gt;&lt;/div&gt;</code></pre><h3 id="v-bind-动态绑定-class-属性"><a href="#v-bind-动态绑定-class-属性" class="headerlink" title="v-bind 动态绑定 class 属性"></a>v-bind 动态绑定 class 属性</h3><p>首先，在传统的 HTML+CSS 代码中，标签绑定 class 属性一般为：</p><p>CSS 代码：</p><pre><code>.active {    color: red;}</code></pre><p>HTML 代码：</p><pre><code>&lt;h2 class="active"&gt;hello world&lt;/h2&gt;</code></pre><p>而在 Vue 中，我们可以使用<code>v-bind</code>对 class 属性进行绑定：</p><p>HTML 代码：</p><pre><code>&lt;h2 :class="active"&gt;hello world&lt;/h2&gt;</code></pre><p>Vue 代码：</p><pre><code>var vm = new Vue({      el: "#app",      data: {          active: 'active'      }     })</code></pre><p>但是，如果仅仅这么来绑定属性的话，很显然毫无意义。</p><p>实际上，一般要使用 v-bind 动态绑定 class 属性的场景为：我们希望动态的来切换class，一个标签某些场景下存在某一个 class 属性，而某些场景下不存在这个 class 属性。</p><p>将 HTML 中 class 的属性值改造为对象：</p><pre><code>&lt;h2 :class="{key1: value1, key2: value2}"&gt;hello world&lt;/h2&gt;</code></pre><p>这个代码在实际动态绑定 class 的应用中表现为：</p><pre><code>&lt;h2 :class="{类名1: boolean, 类名2: boolean}"&gt;hello world&lt;/h2&gt;</code></pre><blockquote><p>当 boolean 值为 true 时，类就会被绑定到标签上，当 boolean 值为 false 时，类就不会被绑定到标签上。</p></blockquote><p>此时，只需要控制 boolean 的值，就能控制类名的动态绑定。应用于最开始的样例，应该被写作：</p><pre><code>&lt;h2 :class="{active: true}"&gt;hello world&lt;/h2&gt;</code></pre><p>既然要操作 boolean 的值，那么，boolean 的值就可以放到 Vue 的实例对象的数据中：</p><p>HTML 代码：</p><pre><code>&lt;h2 :class="{active: isActive}"&gt;hello world&lt;/h2&gt;</code></pre><p>Vue 代码：</p><pre><code>var vm = new Vue({      el: "#app",      data: {          isActive: true      }     })</code></pre><p>这样我们就做到了在 Vue 实例中操作数据，从而动态控制标签中的 class 属性。</p><blockquote><p>说明：当 v-bind 绑定的class与普通class属性同时存在时，并不冲突，实际解析后会同时存在两个类。</p></blockquote><p>当 class 的属性过于复杂时，可以放在一个 methods 中或者 computed 中，此时 classes 是一个计算属性。</p><p>HTML 代码：</p><pre><code>&lt;h2 :class="classes"&gt;hello world&lt;/h2&gt;</code></pre><p>Vue 代码：</p><pre><code>var vm = new Vue({      el: "#app",      data: {          isActive: true,          isHide: false,          isThick: true      },      computed: {          classes: function(){              return {                  active: this.isActive,                  hide： this.isHide,                  thick: this.isThick              };          },      },     });</code></pre><blockquote><p>在上述动态绑定 class 中，是将对象作为 class 的属性值，其实还可以将数组作为 class 的属性值，如：</p><pre><code>&lt;h2 :class="[类名1, 类名2]"&gt;hello world&lt;/h2&gt;</code></pre><p>需要动态绑定 class 类时，只需要修改数组就可以，但是这种用法不常用。</p></blockquote><h3 id="v-bind-动态绑定-style"><a href="#v-bind-动态绑定-style" class="headerlink" title="v-bind 动态绑定 style"></a>v-bind 动态绑定 style</h3><p>除了 v-bind 绑定 class 外，还可以直接利用 v-bind 来绑定一些 CSS 内联样式。</p><p>类似动态绑定 class ，动态绑定 style 的语法如下：</p><pre><code>&lt;h2 :style="{key(属性名): value（属性值）}"&gt;hello world&lt;/h2&gt;</code></pre><p>具体样例如：</p><pre><code>&lt;h2 :style="{font-size: '18px'}"&gt;hello world&lt;/h2&gt;</code></pre><blockquote><ul><li>属性名可以采用驼峰命名法或连接符（-）写法。如，上述代码中属性名还可以写作fontSize。</li><li>属性值需要使用引号引起来，否则，在 Vue 语法中，会将属性值作为一个变量，在 Vue 对象实例中去寻找从而报错。</li></ul></blockquote><p>上述做法只是最基本的语法应用，但如此一来，样式仍是写死在行内样式中，无法灵活的动态绑定 style ，因此，我们可以改进如下：</p><p>HTML 代码：</p><pre><code>&lt;h2 :style="{font-size: finalSize}"&gt;hello world&lt;/h2&gt;</code></pre><p>Vue 代码：</p><pre><code>var vm = new Vue({      el: "#app",      data: {          finalSize: '50px'      }     })</code></pre><p>当 Vue 实例对象的属性值不带单位时，可以通过字符串隐式转换拼接单位：</p><pre><code>&lt;h2 :style="{font-size: finalSize + 'px'}"&gt;hello world&lt;/h2&gt;</code></pre><p>当绑定的 style 非常复杂时，可以抽取出来到 computed 中，例如：</p><p>HTML 代码：</p><pre><code>&lt;h2 :style="styles"&gt;hello world&lt;/h2&gt;</code></pre><p>Vue代码：</p><pre><code>var vm = new Vue({      el: "#app",      data: {          finalSize: '100px',          finalColor: 'red'      },      computed: {          styles: function(){              return {                  fontSize: this.finalSize,                  color: this.finalColor              };          },      },     });</code></pre><blockquote><p> 在上述动态绑定 style 中，是将对象作为 style 的属性值，其实还可以将数组作为 style 的属性值，如：</p><pre><code>&lt;h2 :style="[style1, style2, style3]"&gt;hello world&lt;/h2&gt;</code></pre><p>style 的具体样式在 Vue 的数据中定义。</p><p>需要动态绑定 style 类时，只需要修改数组就可以，但是这种用法不常用。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> 属性操作 </tag>
            
            <tag> v-bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 数据操作 --- Mustache 语法</title>
      <link href="posts/3079.html"/>
      <url>posts/3079.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-数据操作-—-Mustache"><a href="#Vue-数据操作-—-Mustache" class="headerlink" title="Vue 数据操作 — Mustache"></a>Vue 数据操作 — Mustache</h2><p>如何将 data 中的文本数据插入到 HTML 中呢 ？<br>可以通过 Mustache 语法（也就是双大括号）。</p><h3 id="Mustache-基本使用"><a href="#Mustache-基本使用" class="headerlink" title="Mustache 基本使用"></a>Mustache 基本使用</h3><p>我们可以像下面这样使用，并且数据是响应的：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;!-- 插入标签中 --&gt;    &lt;div&gt;hello {{name}}&lt;/div&gt;    &lt;!-- 使用两个Mustache --&gt;    &lt;div&gt;{{firstName}} {{lastName}}&lt;/div&gt;    &lt;!-- 也可以是一个表达式 --&gt;    &lt;div&gt;{{firstName + ' ' + lastName}}&lt;/div&gt;    &lt;div&gt;{{counter * 2}}&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        name: "VueJs",        firstName: "zhang",        lastName: "san",        counter: 100,      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>通过上述基本使用样例，可以看到，在 Mustache 语法中，可以有以下用法：</p><ul><li>直接在标签中插入。</li><li>使用两个 Mustache 进行拼接。</li><li>在 Mustache 中使用表达式。</li></ul><h3 id="v-once-指令"><a href="#v-once-指令" class="headerlink" title="v-once 指令"></a>v-once 指令</h3><p>当某些情况下，可能不希望界面随意的跟随数据改变，就可以使用 <code>v-once</code> 指令。</p><ul><li>该指令后面不需要跟随任何表达式（比如之前的 <code>v-for</code> 后面是有表达式的）。</li><li>该指令表示元素和组件只渲染一次，不会随着数据的改变而改变。</li></ul><p>代码样例：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;div&gt;{{msg}}&lt;/div&gt;    &lt;div v-once&gt;{{msg}}&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        msg: "Vuejs",      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>运行结果：<br><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/21/n8XwKvfopbhYDqA.png" alt="v-once 运行结果.png"></p><h3 id="v-html-指令"><a href="#v-html-指令" class="headerlink" title="v-html 指令"></a>v-html 指令</h3><p>当某些情况下，从服务器请求到的数据本身就是一个 HTML 代码。</p><p>如果直接通过 Mustache 来输出，会将 HTML 代码一并输出，但是我们希望的是按照 HTML 格式进行解析，并且显示对应的内容。</p><p>如果我们希望解析出 HTML 展示，就可以使用 <code>v-html</code> 指令，该指令后面旺旺跟上一个 string 类型，vue 实例对象会将 string 的 html 解析出来并进行数据渲染。</p><p>代码样例：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;div&gt;{{url}}&lt;/div&gt;    &lt;div v-html="url"&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        url: '&lt;a href="https://www.baidu.com/"&gt;百度一下&lt;/a&gt;',      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>执行结果：</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/21/E5RY926P3ps4TiU.png" alt="v-html 运行结果.png"></p><h3 id="v-text-指令"><a href="#v-text-指令" class="headerlink" title="v-text 指令"></a>v-text 指令</h3><p>v-text 作用和 Mustache 比较相似：都是用于将数据显示在界面中。</p><p>通常情况下，接受一个 string 类型。</p><p>代码样例：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;div&gt;{{msg}}&lt;/div&gt;    &lt;div v-text="msg"&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        msg: "hello world",      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>执行结果：</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/21/5Onua6JkLmU7YMo.png" alt="v-text 运行结果.png"></p><blockquote><p>v-text 和 Mustache （双大括号）结果一样，需要注意的是，当使用 Mustache 时，可以进行数据的拼接等操作，而 v-text 则不可以。</p></blockquote><h3 id="v-pre-指令"><a href="#v-pre-指令" class="headerlink" title="v-pre 指令"></a>v-pre 指令</h3><p>当不需要解析 Mustache 语法时，可以使用 v-pre 来跳过这个元素和它子元素的编译过程，用于显示原本的 Mustache 语法。</p><p>比如下面的代码：</p><p>第一个 div 元素中的内容会被编译解析出来对应的内容。</p><p>第二个 div 元素中会直接显示 。</p><p>代码样例：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;div&gt;{{msg}}&lt;/div&gt;    &lt;div v-pre&gt;{{msg}}&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        msg: "hello world",      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>执行结果：</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/21/U8qac4IXSwMPCKd.png" alt="v-pre 运行结果.png"></p><h3 id="v-cloak-指令"><a href="#v-cloak-指令" class="headerlink" title="v-cloak 指令"></a>v-cloak 指令</h3><p>由于浏览器是先加载 HTML 结构，再渲染数据，所以，当频繁刷新页面时，可以看到标签的闪动，此问题可通过 <code>v-cloak</code> 指令进行解决。</p><p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p><p>代码样例：</p><ul><li>CSS 代码</li></ul><pre><code>&lt;style&gt;  [v-cloak] {    display: none;  }&lt;/style&gt;</code></pre><ul><li>HTML 代码</li></ul><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;div v-cloak&gt;{{msg}}&lt;/div&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new Vue({      el: "#app",      data: {        msg: "hello world",      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> Mustache </tag>
            
            <tag> 插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVVM 框架相关</title>
      <link href="posts/844.html"/>
      <url>posts/844.html</url>
      
        <content type="html"><![CDATA[<h2 id="MVVM-框架相关"><a href="#MVVM-框架相关" class="headerlink" title="MVVM 框架相关"></a>MVVM 框架相关</h2><p><strong>MVVM 是 MVC 的增强版，实质上和 MVC 没有本质区别，只是代码的位置变动而已</strong>，这是我对 MVVM 的定义，如果你不知道什么是 MVC ，请往下看。</p><h3 id="MVC-简介"><a href="#MVC-简介" class="headerlink" title="MVC 简介"></a>MVC 简介</h3><p><strong>Model、View、Controller</strong>，分别表示<strong>数据、视图、控制器</strong>。其实这只是一种设计思想，具体用什么语言和做什么开发并不重要。所谓 MVC 便是这几个单词的简写。</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/20/7D43asdV5ockGRu.png" alt="mvc.png"></p><p>简单描述了三者作用：</p><p>Model：数据模型，用来存储数据。</p><p>View：视图界面，用来展示 UI 界面和响应用户交互。</p><p>Controller：控制器（大管家角色），监听模型数据的改变和控制视图行为、处理用户交互。</p><h3 id="MVVM-简介"><a href="#MVVM-简介" class="headerlink" title="MVVM 简介"></a>MVVM 简介</h3><p>既然 MVC 这么好，那为什么还要使用 MVVM ？我们先来看一下 MVVM 是什么。</p><p><img src="/medias/loading/orange.square-circle-preloader.svg" data-original="https://i.loli.net/2020/10/20/DMycpBkCPvKH6lu.png" alt="mvvm.png"></p><p>上图描述了 MVVM 一个基本结构，发现<strong>比 MVC 架构中多了一个 ViewModel **，这个 ViewModel 是 MVVM 相对于 MVC 改进的核心思想。在开发过程中，由于需求的变更或添加，项目的复杂度越来越高，代码量越来越大，此时我们会发现 MVC 维护起来有些吃力，由于 Controller 主要用来处理各种逻辑和数据转化，复杂业务逻辑界面的 Controller 非常庞大，维护困难，所以需要</strong>将 Controller 的数据和逻辑处理部分从中抽离出来，用一个专门的对象去管理，这个对象就是 ViewModel ，是 Model 和 Controller 之间的一座桥梁<strong>。这样拆分后， Controller 中的代码变得非常少，变得易于测试和维护，只需要 **Controller 和 ViewModel 做数据绑定</strong>即可，这也就催生了 MVVM 的热潮。</p><blockquote><p>以上内容来自转载：</p><p>作者：Niuszeng<br>链接：<a href="https://www.jianshu.com/p/6aeeecd64dcf" target="_blank" rel="noopener">https://www.jianshu.com/p/6aeeecd64dcf</a><br>来源：简书</p></blockquote><h3 id="MVVM-相关概念"><a href="#MVVM-相关概念" class="headerlink" title="MVVM 相关概念"></a>MVVM 相关概念</h3><blockquote><p>MVVM（Model–View–Viewmodel）是一种软件架构模式。</p></blockquote><blockquote><p>MVVM 有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或 GUI 代码实现的。 MVVM 的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。</p></blockquote><blockquote><p>MVVM 是马丁·福勒的 PM（Presentation Model）设计模式的变体。  MVVM 以相同的方式抽象出视图的状态和行为，但 PM 以不依赖于特定用户界面平台的方式抽象出视图（创建了视图模型）。<br> MVVM 和 PM 都来自 MVC 模式。</p></blockquote><blockquote><p>MVVM 由微软架构师 Ken Cooper 和 Ted Peters 开发，通过利用 WPF（微软.NET图形系统）和 Silverlight（WPF的互联网应用派生品）的特性来简化用户界面的事件驱动程序设计。 微软的 WPF 和 Silverlight 架构师之一 John Gossman 于2005年在他的博客上发表了 MVVM 。</p></blockquote><blockquote><p>MVVM 也被称为 model-view-binder ，特别是在不涉及 .NET 平台的实现中。 ZK（Java写的一个Web应用框架）和 KnockoutJS（一个JavaScript库）使用model-view-binder 。</p></blockquote><blockquote><p> 以上内容均来自维基百科。<a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener">MVVM wikipedia</a>。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
            <tag> MVVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Vue.js</title>
      <link href="posts/24073.html"/>
      <url>posts/24073.html</url>
      
        <content type="html"><![CDATA[<h2 id="初识-Vue-js"><a href="#初识-Vue-js" class="headerlink" title="初识 Vue.js"></a>初识 Vue.js</h2><p>Vue.js 的官方教程地址：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js</a></p><h3 id="Vue-js-简介"><a href="#Vue-js-简介" class="headerlink" title="Vue.js 简介"></a>Vue.js 简介</h3><ul><li><p>Vue (读音 /vjuː/，类似于 view) 。</p><p>请<strong>不要</strong>按字母读作 V、U、E，否则会显得很<code>外行</code>。</p></li><li><p>是一套用于构建用户界面的<code>渐进式框架</code>。</p><p>Vue 被设计为可以<code>自底向上逐层应用</code>，Vue 的核心库只关注视图层，易上手，还便于与第三方库或既有项目整合。</p><p>当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></li></ul><h3 id="Vue-js-安装"><a href="#Vue-js-安装" class="headerlink" title="Vue.js 安装"></a>Vue.js 安装</h3><p>方式一：直接 CDN 引入。</p><pre><code>&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt;</code></pre><p>方法二：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 官网下载，手动引入。</p><blockquote><p>开发环境：<a href="https://vuejs.org/js/vue,js" target="_blank" rel="noopener">https://vuejs.org/js/vue,js</a></p><p>生产环境：<a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">https://vuejs.org/js/vue.min.js</a></p></blockquote><p>方法三：npm 安装</p><pre><code>$ npm install vue</code></pre><h3 id="Vue-初体验"><a href="#Vue-初体验" class="headerlink" title="Vue 初体验"></a>Vue 初体验</h3><p>首先，我们先来写一个 Hello Vuejs 简单样例，来体会下 Vue 的工作方式：</p><pre><code>&lt;body&gt;    &lt;div id="app"&gt;        {{msg}} //引用声明的数据    &lt;/div&gt;    &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;    &lt;script&gt;        const vm = new Vue({            el: '#app', //用于将 Vue 实例挂载到要管理的元素            data: { //定义数据                msg: 'Hello Vuejs'}        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>Vue的编程范式采用的是声明式编程，给元素一个 <code>id</code> ，然后在 Vue 实例中管理此id，并在 Vue 实例中声明数据等信息，然后在元素中进行引用渲染。</p><blockquote><p>声明式编程有利于 HTML 代码与数据完全分离。</p></blockquote><p>在 Hello Vuejs 的代码中，都做了哪些事情：</p><ol><li><p>创建一个 Vue 对象。</p></li><li><p>对象中包含了一些选项：</p><ol><li>el 属性：该属性决定了这个 Vue 对象挂载到哪一个元素上。</li><li>data 属性：该属性中通常会存储一些数据。这些数据可以是直接定义，也可以来自网络，从服务器加载。</li></ol></li><li><p>浏览器在执行代码过程中，先加载对应的 HTML 结构，后创建 Vue 实例，对元 HTML 进行解析和修改。</p></li></ol><blockquote><p>由于浏览器是先加载 HTML 结构，再渲染数据，所以，当频繁刷新页面时，可以看到标签的闪动，此问题在后边通过 <code>v-cloak</code> 指令进行解决。</p></blockquote><p>接下来，我们来展示一个更加复杂的数据：数据列表。</p><p>当我们从服务器请求到一个列表时，按如下代码展示到 HTML 中：</p><pre><code>&lt;body&gt;  &lt;div id="app"&gt;    &lt;ul&gt;      &lt;li v-for="item in arr"&gt;{{item}}&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: "#app",      data: {        arr: ["数学", "语文", "英语", "Vue"],      },    });  &lt;/script&gt;&lt;/body&gt;</code></pre><p>在HTML代码中，使用 <code>v-for</code> 指令遍历数组并展示，这样就不用在 JavaScript 代码中进行 DOM 的拼接相关操作。</p><p>而且，更重要的是，它还是响应式的，当我们数组中的数据发生改变时，界面会自动改变，如在浏览器开发者模式的 console 中输入 app.arr.push(“化学”) ，界面就会自动添加一个 <code>&lt;li&gt;</code> ，而不用再使用 JavaScript 操作 DOM 了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
